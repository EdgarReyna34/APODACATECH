/*
* Description: ARTIFICIAL INTELLIGENCE AND INTERNET OF THINGS SNESOR PROGRAM
 * Author: EDGAR OMAR REYNA TORRES
 * Date: 06/10/2024
 * HW: FIREBEETLE ESP32 MODULE AND EVAL-ADXL355Z ACCELEROMETER
 */
/*
 * Hardware Connections
 * ======================
* ADXL355 PIN INT1 must be connected to GPIO 35 OF ESP32 pulled down with a
 * 10K Ohm resistor
 *ADXL355 MOSI, MISO and SCLK must be connected to the corresponding pins of the Arduino
 * and the CS pin of the ADXL355 must be connected to pin 2 in the case of using the firebeetle esp32 card
*/
/*
 *
 * Declare libraries
 *
 */
#include <ai_v3_new_acmotor_inferencing.h>
#include <PL_ADXL355.h>                                     //eval.adxl355z library
#include <esp_now.h>                                        //espnow protocol library
#include <WiFi.h>                                           // wifi librery
#include <esp_sleep.h>                                      //low consumption light sleep mode library

/*
 *
 * Defines constants, macros and structures
 *
 */
#define CONVERT_G_TO_MS2    9.80665f
#define FREQUENCY_HZ        EI_CLASSIFIER_FREQUENCY
const float INTERVAL_MS  =       (1000 / (FREQUENCY_HZ));
#define SAMPLING_FREQ_HZ    500       // Sampling frequency (Hz)
const float SAMPLING_PERIOD_MS  = 1000 / SAMPLING_FREQ_HZ ;  // Sampling period (ms)
#define uS_TO_S_FACTOR 1000000  /* Conversion factor for micro seconds to seconds */
#define TIME_TO_SLEEP  14400        /* This variable in units of seconds determines the time the ESP32 will enter light sleep mode. A total of 4 hours */
#define SECONDS_TO_SLEEP 5        /* once the motor start working we create a delay of 5 seconds*/
/*
 *
 * Declare Global Variables
 *
 */
// Variables del algoritmo de desborde de timer y control de ligh sleep y deep sleep
  unsigned long tiempoAnterior = 0;                             //variable de funcion desborde temporizador
  const unsigned long tiempoDesborde = 10000;                   // 5 horas son 18,000,000 milisegundos.
  bool interrupcionFlag = false;                                // Initial state of interrupt flag
// Enable wake up timer and set the time for 4 hours
  uint64_t tiempoParaDormirUs = 4ULL * 60 * 60 * 1000000;       //4 hours in microseconds
  RTC_DATA_ATTR int TIMERflag = 0;
  RTC_DATA_ATTR int EXT0flag = 0;

//Variables for battery reading
  const int pinADC = 36; 
  const float V_REF = 3.293;    //adjusted by measuring pin 36 of esp32 voltage generated by the voltage divider embedded in the card
  const float RESOLUTION = 0.000805860;
  const float V_MIN = 3100;  //3.100 * 1000 adjusted checking battery discharge graph
  const float V_MAX = 3840; //3,900 * 1000 Adjusted by measuring the battery voltage
  float percentage;
  float batteryVoltage;
  float voltageADC;

//Variables and instances for communication and control of the eval-adxl355z
  PL::ADXL355 adxl355(2);                                       //pin CS del ADXL355 debe conectarse al pin 2
  auto range = PL::ADXL355_Range::range2g;                      // Rango del ADXL355: +/- 2 g
  auto activityAxes = PL::ADXL355_Axes::x | PL::ADXL355_Axes::y | PL::ADXL355_Axes::z;       //// Activity detection axes: X and Y and z

// Data output frequency (measuring frequency) of ADXL355: 4000 Hz
  auto outputDataRate = PL::ADXL355_OutputDataRate::odr4000;
  auto interruptactiv = PL::ADXL355_Interrupts::activityInt1;        //La actividad por interrupcion activa el pin INT1
  auto interruptpol = PL::ADXL355_InterruptPolarity::activeHigh;      //polaridad de la interrupcion alto o bajo
  float activityThreshold = 1.5;                                      // Activity detection threshold, g
  uint8_t activityCount = 5;                                          // Activity detection count  max valor que puedo usar es 255
  bool activityInterruptTriggered = false;                            //bandera por interrupcion

// Variables for inference algorithm
  static float features[1500] = {
    // copy raw features here (for example from the 'Live classification' page)
    // see https://docs.edgeimpulse.com/docs/running-your-impulse-arduino
  };
  size_t feature_ix = 0;                                             // keep track of where we are in the feature array
  float x, y, z;
  unsigned long timestamp;
  float goodcondition;
  float imbalancecondition;
  float startcondition;
  float stopcondition;
  float anomalycondition;
  float resultado = 0.0; 
  String nombreVariable = ""; 
  int resultado_inferencia = 0;
  float motor_temperature = 35.67;

// Variables and structures for espnow to operate
//Structure for the data to send
typedef struct struct_message {
    //long tiempo;
    int NoNodo;
    int NivelBateria;
    int ResInferencia;
    int Temperatura;
    //int Condicioninicio;
    //int Condicionparo;
    //int Anomalia;
    //int Dato8;
    //int Dato9;
    //int Dato10;
} struct_message;

// Estructura para el ACK
typedef struct struct_ack {
    bool ack;
} struct_ack;

// Global variable for the message
struct_message myData;

// Global variable for the ACK
struct_ack ack;

//Create a variable of type esp_now_peer_info_t to store information about the peer.
esp_now_peer_info_t peerInfo;

// MAC address of the master node (you should replace this with the actual MAC address of the master node)
uint8_t masterAddress[] = {0xE8, 0x68, 0xE7, 0x2D, 0x9B, 0x6C}; 

// Flag for shipping status
bool acknowledged = false;


unsigned long tiempoInicio, tiempoFinal, tiempoTranscurrido; 

const int maxRetries = 2;      //maximum number of sending attempts
int retries = 0;               //we start with 0 attempts 

/*
 *
 * Function Prototypes
 *
 */  

/**
 * @brief      Copy raw feature data in out_ptr
 *             Function called by inference library
 *
 * @param[in]  offset   The offset
 * @param[in]  length   The length
 * @param      out_ptr  The out pointer
 *
 * @return     0
 */
int raw_feature_get_data(size_t offset, size_t length, float *out_ptr) {
    memcpy(out_ptr, features + offset, length * sizeof(float));
    return 0;
}

void print_inference_result(ei_impulse_result_t result);

/**
 * @brief Enter light sleep with the configured wakeup options
 */
esp_err_t esp_light_sleep_start(void);

/*
*Prints the wake mode of the ESP32 since it is in light sleep mode
*/  
void detect_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason;

  wakeup_reason = esp_sleep_get_wakeup_cause();

  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : EXT0flag=1; break;
    case ESP_SLEEP_WAKEUP_EXT1 : break;
    case ESP_SLEEP_WAKEUP_TIMER : TIMERflag=1; break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : break;
    case ESP_SLEEP_WAKEUP_ULP :  break;
    default :  break;
  }
}     

/*
*Function that generates battery percentage
*/
void reportBatteryPercentage() {
  percentage = readBatteryPercentage(); 
// Here you can add the code to put the ESP32 in sleep mode if you need it.
}

/*
*Function that reads the battery
*/
inline float readBatteryPercentage() {
  int raw = analogRead(pinADC);
  voltageADC = (raw * RESOLUTION);
  voltageADC = voltageADC * 1000;
  batteryVoltage = voltageADC * 2.0;
  return constrain(mapf(batteryVoltage, V_MIN, V_MAX, 0, 100), 0, 100);
}

inline float mapf(float value, float fromLow, float fromHigh, float toLow, float toHigh) {
  return (value - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow;
}

/*
* Function to acquire and save sensor data in buffer xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxSTRONG DOUBT WHEN USING MILLIS OVERFLOW?xxxxxxxxxxxxxxxxxxxxxxxx
*/
void llenarBuffer() {
    while (feature_ix < 1500) {
        unsigned long timestamp = millis();
        auto accelerations = adxl355.getAccelerations();
        
        float x = accelerations.x;
        float y = accelerations.y;
        float z = accelerations.z;
        
        // fill the features buffer
        if (feature_ix < 1498) {  // We ensure not to overflow the buffer
            features[feature_ix++] = x * CONVERT_G_TO_MS2;
            features[feature_ix++] = y * CONVERT_G_TO_MS2;
            features[feature_ix++] = z * CONVERT_G_TO_MS2;
        }
        
        while (millis() < timestamp + SAMPLING_PERIOD_MS);
    }
  //Serial.println("Buffer se a llenado con aprox. 1500 datos.");   
  //Serial.flush(); 
}

/*
* Function that initializes the esp now protocol
*/
void inicializacionESPNow() {

  if (WiFi.getMode() != WIFI_STA) {
    WiFi.mode(WIFI_STA);
  }
    if (esp_now_init() != ESP_OK) {
       // Serial.println("Error al inicializar ESP-NOW");
        //Serial.flush();
        return;
    }

  // Register callback function for when data is received
  esp_now_register_recv_cb(OnDataRecv);

  // Register callback function for when data is sent
  esp_now_register_send_cb(OnDataSent);

  // Configure peer pair
  memcpy(peerInfo.peer_addr, masterAddress, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;

  // Add peer
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    //Serial.println("Error al añadir el par");
    //Serial.flush();
    return;
  }
  //Serial.println("Inicialización de ESP-NOW exitosa");
  //Serial.flush();
}

/*
* Callback function when data is sent
*/
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
 /* Serial.print("Envío de datos a: ");
  for (int i = 0; i < 6; i++) {
    Serial.print(mac_addr[i], HEX);
    if (i < 5) {
      Serial.print(":");
    }
  }
  Serial.println();
  Serial.print("Estado del envío: "); */
  if (status == ESP_NOW_SEND_SUCCESS) {
  //  Serial.println("Éxito");
  } else {
  //  Serial.println("Fallo");
  }
  //Serial.flush();
}

/*
* Callback function when data is received
*/
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  memcpy(&ack, incomingData, sizeof(ack));
  if (ack.ack == 1) { // Verifica si el valor de ACK es el esperado
    acknowledged = true;
    //Serial.println("ACK recibido: Datos confirmados por el nodo maestro");
    //Serial.flush();
  }
}

/*
* Function that initializes variables for the espnow flow
*/
void iniciaVariableEspnow() {
  acknowledged = false; // Restablecer la bandera de acuse de recibo para cada mensaje nuevo
  retries = 0;          //inciamos variable retries.
}

/*
* sending data by espnow
*/
void enviosESPNOW() {
  //Implementation of the Random Exponential Backoff strategy
  while (retries < maxRetries) {
  // Send the data packet by espnow
    esp_err_t result = esp_now_send(masterAddress, (uint8_t *) &myData, sizeof(myData));
    

    if (result == ESP_NOW_SEND_SUCCESS) {
     // Serial.println("Datos enviados correctamente");
  // Wait a reasonable time to receive the ACK from the master node
      unsigned long start = millis();
      unsigned long timeout = 50;         // Tiempo de espera en milisegundos no puedo usar light sleep ya que tengo que estar activo para cachar el ack que viene del maestro
      while (millis() - start < timeout) {
  //If the ack is effective we exit the while
        if (acknowledged) {
          break;
        }
      }

  // Check if the ACK was received
      if (acknowledged) {
  // Leaves the main while and goes to the beginning of the loop
     //   Serial.println("ACK recibido, a dormir hasta siguiente evento");
     //   Serial.flush();
        break; 
      }

//Whether the data was not sent correctly or the ack did not arrive, we proceed to
 //increment by 1 variable retries "retries"
      else {
        //Serial.println("No se recibió ACK, reintentando...");
        //Serial.flush();
        retries++;
      }
    } else {
      //Serial.print("Error al enviar datos, intento: ");
      //Serial.println(retries + 1);
      //Serial.flush();
      retries++;
    }

  // We ask if the shipping limit reached the maximum?
    if (retries < maxRetries) {
  //We generate a delay time before the second and last send
 //this time is achieved using low consumption mode and timed interruption.
      WiFi.mode(WIFI_OFF);          
      esp_sleep_enable_timer_wakeup(1000 * 1000);     
      //Serial.println("Yendo a light sleep por 1 seg"); 
      //Serial.flush();
  //Start low consumption light sleep mode, wake up by timer for 1 sec and then deactivate wake up by timer since currently it will not be a priority
      esp_light_sleep_start();
      desactivarWakeupTimerHastaExito();   
      //Serial.print("Despertando del light sleep, inicializa espnow, intento: ");
      //Serial.println(retries + 1); 
  //Inicializando espnow segundo intento
      //Serial.println("INICIALIZANDO ESPNOW...SEGUNDO INTENTO");
      //Serial.flush();
      inicializacionESPNow();
    }
  }  //hasta aqui llega while
}

/*
* DISABLE WAKE UP BY TIME
*/
esp_err_t desactivarWakeupTimerHastaExito() {
    esp_err_t ret;
    int intentos = 0; // Contador para el número de intentos

    do {
        ret = esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);
        intentos++; // Incrementa el contador de intentos con cada iteración
        if (ret != ESP_OK) {
            //delay(1); // Espera un poco antes de intentarlo nuevamente
        }
    } while (ret != ESP_OK && intentos < 3); // Se corrigió la condición del bucle: sigue en el bucle si ret NO es ESP_OK y se han realizado menos de 3 intentos
    //Serial.println("DESACTIVACION TIMER WAKEUP NO EXITOSA");
    return ret; // ret podría no ser ESP_OK si se alcanzó el límite de intentos
}

/*
* DISABLE WAKE UP BY INT0
*/
esp_err_t desactivarWakeupExt0HastaExito() {
    esp_err_t ret;
    int intentos = 0; 

    do {
        ret = esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_EXT0);
        intentos++; 
        if (ret != ESP_OK) {
            //delay(1); // Espera un poco antes de intentarlo nuevamente
        }
    } while (ret != ESP_OK && intentos < 3); // Se corrigió la condición del bucle: sigue en el bucle si ret NO es ESP_OK y se han realizado menos de 3 intentos
    //Serial.println("DESACTIVACION EXT0 WAKEUP NO EXITOSA");
    return ret; // ret podría no ser ESP_OK si se alcanzó el límite de intentos
}

/*
* Wakeup control for deepsleep code
*/
void control_wakeup() {
    if (EXT0flag == 0 && TIMERflag == 0){                  //THIS HAPPENS IN A POWER UP STATE WHERE NO FLAG WAS ACTIVATED AND THE PROGRAM WAS EXECUTED, WHAT IS DONE NOW IS ACTIVATE INT EXT0 AND INT TIMER AND WAIT FOR SOME OF THESE TO BE ACTIVATED AT SOME POINT OF TIME AND THE PROGRAM IS EXECUTED
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_35,1);
    esp_sleep_enable_timer_wakeup(tiempoParaDormirUs);     // time the esp will sleep in microsec
  }

  if (EXT0flag == 1 && TIMERflag == 1) {                   //Initially the MCU woke up due to an INT EXT0 and after 5 seconds of time the INT TIMER was activated, THE CODE WAS EXECUTED AND AT THE END WE DEACTIVATED THE EXTERNAL INTS BECAUSE WE MUST SAVE BATTERY, UNTIL 4/8HRS EAP THE MCU WILL WAKE UP AND RESET CYCLE CONDITIONS
    //Serial.println("Desperte por INTERRUPCION EXTERNAJAJA");
    desactivarWakeupExt0HastaExito();
    EXT0flag = 0;    // Borra bandera de EXT0flag
    TIMERflag = 0;   // Borra bandera de TIMER
    esp_sleep_enable_timer_wakeup(tiempoParaDormirUs);     
  }

  if (EXT0flag == 0 && TIMERflag == 1) {                  
    //Serial.println("Desperte por INTERRUPCION POR TIMERRRRRUM");
    EXT0flag = 0;    // Borra bandera de EXT0flag
    TIMERflag = 0;
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_35,1);
    esp_sleep_enable_timer_wakeup(tiempoParaDormirUs);     
  }

  
}

/*
* Generate a delay when sensor detects motor starting
*/
void motor_start_detection() {
    if (EXT0flag == 1 && TIMERflag == 0){
    //Serial.println("Desperte por INT0 esperar 5 seg antes de procesar inferencia");
    //Serial.flush();
    desactivarWakeupExt0HastaExito();
    esp_sleep_enable_timer_wakeup(SECONDS_TO_SLEEP * uS_TO_S_FACTOR);     // tiempo que dormira el esp en microseg
    esp_deep_sleep_start(); 
  }
}

/*
* Sending data every 8 hours to maximize battery and sensor life
*/
void lowbatteryalgorithm() {
 if (percentage < 30){                                       //If battery level is less than 30%, the deepsleep mode will last 8 hours instead of 4, this will cause 3 measurements per day instead of 6 measurements. prolonging battery life for longer
   tiempoParaDormirUs = 8ULL * 60 * 60 * 1000000;
 }
 else {
  tiempoParaDormirUs = 4ULL * 60 * 60 * 1000000;
 }
}

//*********************************************************************************************************************
//*******************************SETUP*********************************************************************************
//*********************************************************************************************************************
/*
 *
 * Funcion Setup
 *
 */  
void setup() {

  Serial.begin(115200);
  while(!Serial);                                       // Wait for Serial ready state  
  //Serial.println("****INICIO DE SETUP****");  
  //Serial.flush();

// Initialize the accelerometer
  adxl355.begin();
  adxl355.setRange(range);
  adxl355.setOutputDataRate(outputDataRate);
  adxl355.setInterrupts(interruptactiv);                // Enable activity interruption on INT1
  adxl355.setInterruptPolarity(interruptpol);           // Set the interrupt polarity to "active high"
  adxl355.setActivityDetectionAxes(activityAxes);             // Set activity detection axes

// Set the activity threshold (adjust it according to your needs)
  adxl355.setActivityDetectionThreshold(activityThreshold);  
  adxl355.setActivityDetectionCount(activityCount);         
  adxl355.enableMeasurement();
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_35,1); 
  esp_sleep_enable_timer_wakeup(tiempoParaDormirUs);    
  analogReadResolution(12);                             

}

/*
 *
 * Funcion Loop
 *
 */
/**
 * @brief      Arduino main function
 */ 
void loop() {
 /*detects which mode woke up the deepsleep module and sets the relevant flag to logical 1*/ 
  detect_wakeup_reason();

/*detects engine start through wakeup due to EXT0 interruption*/
  motor_start_detection();

/*clears flag that may have been left high due to some detected acceleration. If the function is not read, the flag remains active indefinitely.*/
  adxl355.getStatus(); 

  interrupcionFlag = true;

  interrupcionFlag = false;                                  //Apagamos bandera para cuando el porgrama regrese a la linea 1 valla light sleep
/*deletes flag that may have been left high due to some detected acceleration*/                    
  adxl355.getStatus();

/* we read battery value */
  reportBatteryPercentage();                                 //Leemos el nivel de bateria a fin de conocer que algoritmo aplicar

/*Algorithm 2 for low battery level   */
  lowbatteryalgorithm();

/*Activates measurements to the sensor*/                    
  adxl355.enableMeasurement();                               

/*Read the sensor and store the data in an array in the same way as in the data forwarder code   */
  llenarBuffer();
  //Serial.println("Edge Impulse Inferencing Started");

/*Here we can add the inference algorithm that we obtain from the library generated by edge impulse! */
  //Serial.println("");   
  //ei_printf("Edge Impulse standalone inferencing (Arduino)\n");
  if (sizeof(features) / sizeof(float) != EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE) {
   return;
  }

/* call the impulse function*/  
    ei_impulse_result_t result = { 0 };

/* the features are stored into flash, and we don't want to load everything into RAM   */
    signal_t features_signal;
    features_signal.total_length = sizeof(features) / sizeof(features[0]);
    features_signal.get_data = &raw_feature_get_data;

/* we invoke the impulse      */
    EI_IMPULSE_ERROR res = run_classifier(&features_signal, &result, false /* debug */);
    if (res != EI_IMPULSE_OK) {
      //  ei_printf("ERR: Failed to run classifier (%d)\n", res);
        return;
    }

/* Print inference   
    ei_printf("run_classifier returned: %d\r\n", res);
    print_inference_result(result);
    Serial.flush();      *7

/* reset features frame     */
    feature_ix = 0;         
    adxl355.clearFifo();
    //Serial.println("INFERENCIA TERMINADA ");
    //Serial.flush();

/* save inference result    */
  goodcondition = result.classification[0].value;
  imbalancecondition = result.classification[1].value;
  startcondition = result.classification[2].value;
  stopcondition = result.classification[3].value;
  anomalycondition = result.anomaly;

  /*Serial.println("IMPRIME RESULTADO DE INFERENCIA ");
  Serial.println();
  Serial.print("goodcondition = ");
  Serial.println(goodcondition);
  Serial.print("imbalancecondition = ");
  Serial.println(imbalancecondition);
  Serial.print("startcondition = ");
  Serial.println(startcondition);
  Serial.print("stopcondition = ");
  Serial.println(stopcondition);
  Serial.print("anomalycondition = ");
  Serial.println(anomalycondition);
  Serial.print("Porcentaje de bateria = ");
  Serial.println(percentage);
  Serial.print("Voltaje en PIN 36:  ");
  Serial.println(voltageADC);
  Serial.flush();  */


 /*Find which of the results is higher and if it is greater than 0.75, both the variable and the result, print it*/ 
  float maxValor = goodcondition; 
  nombreVariable = "goodcondition"; 
  resultado_inferencia = 1;

  if (imbalancecondition > maxValor) {
    maxValor = imbalancecondition;
    nombreVariable = "imbalancecondition";
    resultado_inferencia = 2;
  }
  if (startcondition > maxValor) {
    maxValor = startcondition;
    nombreVariable = "startcondition";
    resultado_inferencia = 3;
  }
  if (stopcondition > maxValor) {
    maxValor = stopcondition;
    nombreVariable = "stopcondition";
    resultado_inferencia = 4;
  }

  // If the largest value is greater than 0.8, update 'result' and print the variable name and its value
  if (maxValor > 0.8) {
    resultado = maxValor;
    /*Serial.print("La variable con el valor maximo es ");
    Serial.print(nombreVariable);
    Serial.print(", y su valor es: ");
    Serial.println(resultado);*/
  } else {
    resultado_inferencia = 0;
  }

//A result greater than 3 will give us an anomaly detection.
  if (anomalycondition > 3) {
    resultado = anomalycondition;
    resultado_inferencia = 5;
  }

//Save the variables in the package that will be sent by espnow
  myData.NoNodo = 1; 
  myData.NivelBateria = (int) floor (percentage);
  myData.ResInferencia = resultado_inferencia;
  myData.Temperatura = (int)floor (motor_temperature);

  inicializacionESPNow();

  iniciaVariableEspnow();

/* Sending data through espnow + strategy to avoid commission for simultaneous sending    */
  enviosESPNOW();
  if (!acknowledged) {
    //Serial.println("***Máximo de reintentos alcanzado. El mensaje no fue entregado.");
    //Serial.flush();
  }

/* We turn off wifi before going to sleep              */
  WiFi.mode(WIFI_OFF);    

  control_wakeup();

/* Start low consumption mode light sleep wake up by timer 10 sec                 */
  esp_deep_sleep_start(); 
      
} 


//*********************************************************************************************************************
//**********************FIN DEL PROGRAMA*******************************************************************************
//*********************************************************************************************************************



/*
*
* Function that prints inference result
*
*/
void print_inference_result(ei_impulse_result_t result) {


    // Print the prediction results (object detection)
#if EI_CLASSIFIER_OBJECT_DETECTION == 1
   // ei_printf("Object detection bounding boxes:\r\n");
    for (uint32_t i = 0; i < result.bounding_boxes_count; i++) {
        ei_impulse_result_bounding_box_t bb = result.bounding_boxes[i];
        if (bb.value == 0) {
            continue;
        }
       /* ei_printf("  %s (%f) [ x: %u, y: %u, width: %u, height: %u ]\r\n",
                bb.label,
                bb.value,
                bb.x,
                bb.y,
                bb.width,
                bb.height);*/
    }

    // Print the prediction results (classification)
#else
    ei_printf("Predictions:\r\n");
    for (uint16_t i = 0; i < EI_CLASSIFIER_LABEL_COUNT; i++) {
       // ei_printf("  %s: ", ei_classifier_inferencing_categories[i]);
       // ei_printf("%.5f\r\n", result.classification[i].value);
    }
#endif

    // Print anomaly result (if it exists)
#if EI_CLASSIFIER_HAS_ANOMALY == 1
   // ei_printf("Anomaly prediction: %.3f\r\n", result.anomaly);
#endif

}
//*********************************************************************************************
//*********************************************************************************************


